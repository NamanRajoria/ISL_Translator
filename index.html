<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>ISL Translator</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    /* --- NEW COLOR THEME (Light Mode + Blue/Grey Bubbles) --- */
    --app-bg: #Fef6e6;       /* iOS-style Off-White */
    --panel-bg: #FFFFFF;     /* Pure White */
    --text-main: #000000;
    --text-muted: #8E8E93;
    
    --bubble-blue: #007AFF;  /* iMessage Blue */
    --bubble-grey: #E5E5EA;  /* iMessage Grey */
    --text-on-blue: #FFFFFF;
    --text-on-grey: #000000;
    
    --accent: #007AFF;
  }

  html,body{height:100%;margin:0;background:var(--app-bg);color:var(--text-main);font-family:Inter,system-ui,Arial;}
  .app{max-width:920px;margin:12px auto;padding:12px;box-sizing:border-box;}
  .container{display:grid;grid-template-columns:1fr;gap:12px;}
  @media(min-width:900px){ .container{grid-template-columns: 1fr 420px; align-items:start;} }

  /* Camera Container */
  .camera-wrap{ 
    background: #000; 
    border-radius: 20px; /* Rounder corners */
    overflow:hidden; 
    position:relative; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    display:flex;flex-direction:column; min-height:0; align-items:center; 
  }
  
  #canvas{width:100%;height:100%;display:block;background:#000; object-fit: fill;}
  
  .controls-top{position:absolute;left:12px;top:12px;display:flex;gap:8px;z-index:40}
  .ctrl-btn{padding:8px 12px;border-radius:20px;border:0;background:rgba(0,0,0,0.4);backdrop-filter:blur(5px);color:white;cursor:pointer;font-weight:600; font-size:13px;}
  
  .hud-bottom{
    position:relative;padding:16px;
    background:var(--panel-bg); /* White */
    display:flex;flex-direction:column;gap:12px;width:100%; box-sizing: border-box;
    border-top: 1px solid #eee;
  }
  
  .detected-large{font-size:32px;font-weight:800;color:var(--text-main);text-align:center; min-height: 40px;}
  
  .buffer-row{display:flex;gap:8px;align-items:center;justify-content:center}
  
  /* buffer text box */
  .buffer{
    flex:1;padding:12px;border-radius:12px;
    background:#F2F2F7; /* Light grey input look */
    color:var(--text-main);
    font-weight:700;min-height:48px;text-align:center;
    font-size: 20px; border: 1px solid #e5e5e5;
  }
  
  /* Buttons */
  .send-btn{width:56px;height:48px;border-radius:12px;border:0;background:var(--accent);color:white;font-weight:800;font-size:20px;cursor:pointer; transition: opacity 0.2s;}
  .send-btn:active{opacity: 0.7;}
  
  .del-btn{width:56px;height:48px;border-radius:12px;border:0;background:#FF3B30;color:white;font-weight:600;font-size:20px;cursor:pointer; opacity: 0.9;}
  .del-btn:active{opacity:0.7;}

  /* Chat Panel */
  .chat-panel{
    background:var(--panel-bg);
    padding: 16px;
    border-radius: 20px;
    box-shadow: 0 2px 15px rgba(0,0,0,0.05);
    min-height:300px;display:flex;flex-direction:column;gap:12px
  }
  
  .chat-window{
    background: white; /* Clean white bg */
    padding:10px;
    border-radius:10px;
    height: 35px; /* Fixed height for scroll */
    max-height:60vh;
    overflow-y:auto;
    display: flex;
    flex-direction: column;
  }
  
  .chat-controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  
  .mic-btn{width:50px;height:50px;border-radius:50%;border:0;background:#F2F2F7;color:var(--text-main);font-size:20px;cursor:pointer;}
  .input{flex:1;padding:12px;border-radius:24px;border:1px solid #ddd;background:#F9F9F9;color:var(--text-main); outline:none;}
  .send-local{padding:10px 20px;border-radius:24px;border:0;background:var(--accent);color:white;cursor:pointer; font-weight:600;}
  .clear-chat{padding:8px 10px;border-radius:8px;border:0;background:transparent;color:var(--text-muted);cursor:pointer;margin-left:auto; font-size:12px;}
  
  /* --- NEW BUBBLE STYLES --- */
  .bubble {
    padding: 10px 16px;
    border-radius: 18px;
    margin-bottom: 8px;
    word-break: break-word;
    max-width: 80%;
    font-size: 15px;
    line-height: 1.4;
    position: relative;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  
  /* BLUE BUBBLE (ISL / You) - Right Aligned */
  .bubble.isl {
    background: var(--bubble-blue);
    color: var(--text-on-blue);
    align-self: flex-end; /* Moves to Right */
    border-bottom-right-radius: 4px; /* Message styling */
  }
  
  /* GREY BUBBLE (English / Them) - Left Aligned */
  .bubble.eng {
    background: var(--bubble-grey);
    color: var(--text-on-grey);
    align-self: flex-start; /* Moves to Left */
    border-bottom-left-radius: 4px;
  }

  /* Style the "ISL ->" text to look like a label */
  .bubble strong {
    display: block;
    font-size: 10px;
    margin-bottom: 2px;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .small{font-size:12px;color:var(--text-muted); text-align: center; margin-top: 10px;}
  .perm{padding:10px;border-radius:8px;background:#FF3B30;color:white;margin:8px;display:none}
  
  .chat-window::-webkit-scrollbar{width:6px}
  .chat-window::-webkit-scrollbar-track{background:transparent;}
  .chat-window::-webkit-scrollbar-thumb{background:#ccc;border-radius:6px}
</style>
</head>
<body>
  <div class="app">
    <div class="container">
      <div class="camera-wrap" id="cameraWrap">
        <div class="controls-top">
          <button class="ctrl-btn" id="start">Start</button>
          <button class="ctrl-btn" id="stop">Stop</button>
          <button class="ctrl-btn" id="clearBufferBtn">Clear All</button>
        </div>

        <video id="video" autoplay playsinline muted style="display:none"></video>
        <canvas id="canvas" width="640" height="640" aria-label="Camera preview"></canvas>

        <div class="hud-bottom">
          <div style="display:flex;align-items:center;justify-content:center;">
            <div class="detected-large" id="label">â€”</div>
          </div>
          <div class="buffer-row">
            <div id="buffer" class="buffer" aria-live="polite">â€”</div>
            <button id="backspaceBtn" class="del-btn" title="Backspace">âŒ«</button>
            <button id="sendBtn" class="send-btn" title="Send">â†’</button>
          </div>
        </div>

        <div class="perm" id="perm">Camera permission appears blocked. Tap Start then allow camera in your browser settings.</div>
      </div>

      <div class="chat-panel">
        <div style="font-weight:700; color:var(--text-main); display:flex; justify-content:space-between; align-items:center;">
          Conversation
          <button id="clearChat" class="clear-chat">Clear History</button>
        </div>
        
        <div class="chat-window" id="chatWindow" aria-live="polite">
            </div>

        <div class="chat-controls">
          <button id="micBtn" class="mic-btn" title="Tap to talk">ðŸŽ¤</button>
          <input id="transcript" class="input" placeholder="Type or speak..." />
          <button id="localSend" class="send-local">Send</button>
        </div>
        <div class="small">Tip: Hold a letter steady for 2s to add it to the buffer. Remove hands for 2s to insert a space.</div>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ---------------- CONFIG ---------------- */
const INFER_FPS = 15;
const LETTER_HOLD_MS = 2000;
const NO_HAND_MS = 2000;
const SMOOTH_WINDOW = 4;
let rafId = null;

/* ---------------- DOM ---------------- */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const clearBufferBtn = document.getElementById('clearBufferBtn');
const backspaceBtn = document.getElementById('backspaceBtn');
const labelEl = document.getElementById('label');
const bufferEl = document.getElementById('buffer');
const perm = document.getElementById('perm');
const sendBtn = document.getElementById('sendBtn');

const chatWindow = document.getElementById('chatWindow');
const micBtn = document.getElementById('micBtn');
const transcript = document.getElementById('transcript');
const localSend = document.getElementById('localSend');
const clearChat = document.getElementById('clearChat');

/* ---------------- Model Loader ---------------- */
let weights=null, classes=null;
(async function loadW(){
  const MODEL_FILES = ['weights.json','model-weights.json','model_weights.json'];
  for(const n of MODEL_FILES){
    try{ const r=await fetch(n); if(!r.ok) continue; const j=await r.json(); weights=j; classes=j.classes||null; return; }catch(e){}
  }
})();

function denseForward(x,kernel,bias){ const inD=kernel.length, outD=kernel[0].length; const out=new Float32Array(outD); for(let j=0;j<outD;j++){ let s=0; for(let i=0;i<inD;i++) s+=x[i]*kernel[i][j]; s+=bias[j]; out[j]=s;} return out;}
function relu(x){ for(let i=0;i<x.length;i++) if(x[i]<0) x[i]=0; return x;}
function softmax(x){ let max=-Infinity; for(let i=0;i<x.length;i++) if(x[i]>max) max=x[i]; let s=0; const out=new Float32Array(x.length); for(let i=0;i<x.length;i++){ out[i]=Math.exp(x[i]-max); s+=out[i]; } for(let i=0;i<x.length;i++) out[i]/=s; return out;}
function argmax(a){ let b=0; for(let i=1;i<a.length;i++) if(a[i]>a[b]) b=i; return b; }

/* ---------------- Mediapipe ---------------- */
const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });

// NOTE: selfieMode is FALSE. We manually mirror the canvas. 
// This ensures landmarks line up correctly with the mirrored video.
hands.setOptions({ maxNumHands:2, modelComplexity:1, selfieMode:false, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
hands.onResults(onResults);

/* ---------------- State Vars ---------------- */
let recentPreds = [];
let wordBuffer = '';
let candidateLabel = null;
let candidateStart = 0;
let lastHandSeenAt = 0;
let spaceInsertedAt = 0;
let lastAppendTime = 0;
let lastTick = 0;

/* ---------------- Start Camera ---------------- */
startBtn.onclick = async () => {
  perm.style.display='none';
  try{
    // NO specific resolution constraints. 
    // This allows iPhone to use full sensor (no zoom).
    const constraints = { video: { facingMode: 'user' }, audio: false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();

    // Internal resolution for drawing (canvas stretches to fit screen)
    canvas.width = 640;
    canvas.height = 640; 

    lastTick = performance.now();
    if(!rafId) rafId = requestAnimationFrame(tick);
  }catch(e){
    perm.style.display='block';
    console.error('Camera error', e);
    alert('Camera error: '+ (e.message || e.name));
  }
};

stopBtn.onclick = ()=> {
  if(video.srcObject){
    try{ video.srcObject.getTracks().forEach(t=>t.stop()); }catch(e){}
    video.srcObject = null;
  }
  if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
};

/* ---------------- Controls ---------------- */
clearBufferBtn.onclick = ()=>{ wordBuffer=''; bufferEl.innerText='â€”'; };

// NEW: Backspace Button Logic
backspaceBtn.onclick = () => {
  if(wordBuffer.length > 0){
    wordBuffer = wordBuffer.slice(0, -1);
    bufferEl.innerText = wordBuffer || 'â€”';
  }
};

sendBtn.onclick = ()=> {
  const text = wordBuffer.trim();
  if(!text) return;
  addChatBubble(text, 'ISL');
  try{ const u = new SpeechSynthesisUtterance(text); u.lang='en-US'; speechSynthesis.cancel(); speechSynthesis.speak(u); }catch(e){}
  wordBuffer=''; bufferEl.innerText='â€”';
};

/* ---------------- Main Loop ---------------- */
async function tick(ts){
  rafId = requestAnimationFrame(tick);
  const dt = ts - lastTick;
  if(dt < (1000/INFER_FPS)) return;
  lastTick = ts;
  if(video.readyState >= 2){
    await hands.send({ image: video });
  }
}

/* ---------------- Draw & Predict ---------------- */
function onResults(results){
  const w = canvas.width;
  const h = canvas.height;
  
  ctx.save();
  ctx.clearRect(0, 0, w, h);
  
  // MANUAL MIRROR: Flip horizontally
  ctx.translate(w, 0);
  ctx.scale(-1, 1);
  
  // Draw Video (Mirrored)
  if(video.readyState >= 2){
    ctx.drawImage(video, 0, 0, w, h);
  }

  const now = performance.now();
  if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
    lastHandSeenAt = now;
    const handsArr = results.multiHandLandmarks;

    // Draw landmarks (coordinates are raw, so they get flipped by ctx)
    drawLandmarksSimple(handsArr, w, h);

    // Predict
    const all_hands_px = handsArr.map(hand => hand.map(lm => ({ x: lm.x * w, y: lm.y * h })));
    const vec = twoHandsXYToVector(all_hands_px);

    let voted = null;
    if(weights){
      try{
        let out0 = denseForward(vec, weights.layers[0].kernel, weights.layers[0].bias); out0 = relu(out0);
        let out1 = denseForward(out0, weights.layers[1].kernel, weights.layers[1].bias); out1 = relu(out1);
        let out2 = denseForward(out1, weights.layers[2].kernel, weights.layers[2].bias);
        const probs = softmax(out2); const idx = argmax(probs);
        voted = (weights.classes && weights.classes[idx]) ? weights.classes[idx] : String(idx);
        recentPreds.push(voted); if(recentPreds.length > SMOOTH_WINDOW) recentPreds.shift();
        const counts = {}; for(const v of recentPreds) counts[v] = (counts[v]||0)+1;
        let mv = recentPreds[recentPreds.length-1]; let maxc=0;
        for(const k in counts) if(counts[k] > maxc){ maxc = counts[k]; mv = k; }
        voted = mv;
      }catch(e){ voted = null; }
    } else { voted = null; }

    labelEl.innerText = voted || 'â€”';

    // Buffer logic
    if(voted){
      if(candidateLabel !== voted){
        candidateLabel = voted;
        candidateStart = now;
      } else {
        if(now - candidateStart >= LETTER_HOLD_MS){
          if(now - lastAppendTime > 300){
            wordBuffer += candidateLabel;
            bufferEl.innerText = wordBuffer;
            lastAppendTime = now;
          }
          candidateLabel = null; candidateStart = 0;
        }
      }
    } else { candidateLabel = null; candidateStart = 0; }

  } else {
    labelEl.innerText = 'â€”';
    if(now - lastHandSeenAt >= NO_HAND_MS && wordBuffer && (now - spaceInsertedAt > NO_HAND_MS)){
      if(wordBuffer.slice(-1) !== ' '){ wordBuffer += ' '; bufferEl.innerText = wordBuffer; spaceInsertedAt = now; }
    }
    candidateLabel = null; candidateStart = 0;
  }
  
  ctx.restore();
}

function drawLandmarksSimple(handsArr, w, h){
  ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2;
  const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];

  for(const hand of handsArr){
    for(const c of connections){
      const a = hand[c[0]], b = hand[c[1]];
      ctx.beginPath();
      ctx.moveTo(a.x * w, a.y * h);
      ctx.lineTo(b.x * w, b.y * h);
      ctx.stroke();
    }
    for(let i=0;i<hand.length;i++){
      const p = hand[i];
      ctx.beginPath(); 
      ctx.arc(p.x * w, p.y * h, i===8?6:4, 0, Math.PI*2); 
      ctx.fill();
    }
  }
}

/* ---------------- Vectorization ---------------- */
function twoHandsXYToVector(all_hands_px){
  if(all_hands_px.length >= 2) all_hands_px = all_hands_px.sort((a,b)=>a[0].x - b[0].x);
  function singleVec(pxs){
    const wrist = pxs[0]; const pts=[]; let maxd=0;
    for(let i=0;i<pxs.length;i++){ const dx = pxs[i].x - wrist.x, dy = pxs[i].y - wrist.y; pts.push(dx); pts.push(dy); const d=Math.hypot(dx,dy); if(d>maxd) maxd=d; }
    if(maxd===0) maxd=1; const out = new Float32Array(42);
    for(let i=0;i<21;i++){ out[i*2]=pts[i*2]/maxd; out[i*2+1]=pts[i*2+1]/maxd; } return out;
  }
  const v1 = (all_hands_px.length>=1)? singleVec(all_hands_px[0]) : new Float32Array(42);
  const v2 = (all_hands_px.length>=2)? singleVec(all_hands_px[1]) : new Float32Array(42);
  const concat = new Float32Array(84); concat.set(v1,0); concat.set(v2,42); return concat;
}

/* ---------------- Permissions Hint ---------------- */
(async function checkPerm(){ if(!navigator.permissions) return; try{ const s = await navigator.permissions.query({name:'camera'}).catch(()=>null); if(s && s.state === 'denied') document.getElementById('perm').style.display='block'; }catch(e){} })();

/* ---------------- Chat + STT ---------------- */
// MODIFIED: Labels changed to ISL / English
function addChatBubble(text, who='ISL'){
  const el = document.createElement('div');
  el.className = 'bubble ' + (who === 'ISL' ? 'isl' : 'eng');
  
  // LABELS UPDATED HERE
  const label = who === 'ISL' ? 'ISL' : 'English';
  el.innerHTML = `<strong>${label} â†’</strong> ${escapeHtml(text)}`;
  
  chatWindow.appendChild(el);
  chatWindow.scrollTop = chatWindow.scrollHeight;
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

let recognition = null;
let listening = false;
if('webkitSpeechRecognition' in window || 'SpeechRecognition' in window){
  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new Rec();
  recognition.lang = 'en-US';
  recognition.interimResults = true;
  recognition.onresult = (ev) => {
    let interim = ''; let finalTrans = '';
    for(let i=0;i<ev.results.length;i++){
      const r = ev.results[i];
      if(r.isFinal) finalTrans += r[0].transcript;
      else interim += r[0].transcript;
    }
    transcript.value = (finalTrans + interim).trim();
  };
  recognition.onend = ()=> { listening=false; micBtn.style.opacity=1; micBtn.innerText='ðŸŽ¤'; };
  recognition.onerror = (e)=> { console.warn('STT error', e); listening=false; micBtn.style.opacity=1; micBtn.innerText='ðŸŽ¤'; };
} else { micBtn.disabled = true; micBtn.title = 'SpeechRecognition not supported'; }
micBtn.addEventListener('click', ()=>{
  if(!recognition) return;
  if(!listening){ recognition.start(); listening=true; micBtn.style.opacity=0.8; micBtn.innerText='â—'; }
  else { recognition.stop(); listening=false; micBtn.style.opacity=1; micBtn.innerText='ðŸŽ¤'; }
});

// Update Local Send to use 'English' label
localSend.addEventListener('click', ()=>{ 
  const t = transcript.value.trim(); 
  if(!t) return; 
  addChatBubble(t, 'English'); 
  try{ const u = new SpeechSynthesisUtterance(t); u.lang='en-US'; speechSynthesis.cancel(); speechSynthesis.speak(u); }catch(e){} 
  transcript.value=''; 
});

clearChat.addEventListener('click', ()=> { chatWindow.innerHTML = ''; });
</script>
</body>

</html>


